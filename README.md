# Лабораторная работа №2

## Лабор Тимофей Владимирович P3325

## Требования

**Цель:** Освоить построение пользовательских типов данных, полиморфизм, рекурсивные алгоритмы и средства тестирования (unit testing, property-based testing), а также разделение интерфейса и особенностей реализации.

**Задача:** Реализовать структуру данных — мультимножество (bag) на основе AVL-дерева.

**Требования к API:**

- **Добавление элемента** (`add/2`): добавляет элемент в мультимножество.
- **Удаление элемента** (`remove/2`): уменьшает количество вхождений элемента или удаляет его.
- **Подсчет элементов** (`count/2`): возвращает количество вхождений элемента.
- **Проверка наличия** (`contains?/2`): проверяет, есть ли элемент в мультимножестве.
- **Фильтрация** (`filter/2`): возвращает новое мультимножество, содержащее элементы, удовлетворяющие предикату.
- **Отображение** (`map/2`): применяет функцию к каждому элементу, создавая новое мультимножество.
- **Свертки** (`foldl/3`, `foldr/3`): левая и правая свертки для обработки элементов.
- **Размер** (`size/1`): возвращает общее количество элементов с учетом их множественности.
- **Проверка пустоты** (`empty?/1`): возвращает `true`, если мультимножество пустое.
- **Моноидальные свойства**: наличие нейтрального элемента (пустое мультимножество) и ассоциативной операции объединения.
- **Сравнение мультимножеств**: эффективное сравнение на основе содержимого, без приведения к спискам.

**Требования к реализации:**

- Неизменяемость данных.
- Полиморфизм через реализацию протокола `Multiset`.
- Тестирование: unit-тесты и property-based тесты (не менее 3 свойств, включая моноидальные).
- Эффективная реализация операций, включая сравнение.

**Технология:** Elixir, с использованием библиотек ExUnit для unit-тестов и PropCheck для property-based тестирования.

## Ключевые элементы реализации

### Структура данных

Реализовано мультимножество на основе AVL-дерева (`Multiset.AVLMultiset`), которое поддерживает автоматическую балансировку для обеспечения логарифмической сложности операций. Структура состоит из:

- Корневого узла (`root`), представляющего AVL-дерево.
- Поля `size`, хранящего общее количество элементов с учетом их множественности.
- Узла (`Node`), содержащего значение (`value`), количество вхождений (`count`), высоту (`height`), левое и правое поддерево (`left`, `right`).

### Основные функции

- **Добавление (`add/2`)**: Рекурсивно вставляет элемент в AVL-дерево, увеличивая счетчик вхождений, если элемент уже существует. После вставки выполняется балансировка.
- **Удаление (`remove/2`)**: Уменьшает счетчик вхождений элемента или удаляет узел, если счетчик становится равным нулю. Балансировка выполняется после удаления.
- **Фильтрация (`filter/2`)**: Рекурсивно обходит дерево, сохраняя элементы, удовлетворяющие предикату, в новое мультимножество.
- **Отображение (`map/2`)**: Применяет функцию к каждому значению, создавая новое мультимножество.
- **Свертки (`foldl/3`, `foldr/3`)**: Выполняют левую и правую свертку, передавая значение и его количество в аккумулятор.
- **Сравнение**: Реализовано через свертку содержимого двух мультимножеств для подсчета и сравнения элементов, избегая неэффективного приведения к спискам.

### Полиморфизм

Полиморфизм реализован через протокол `Multiset`, который определяет интерфейс для работы с мультимножествами. Модуль `Multiset.AVLMultiset` реализует этот протокол, обеспечивая независимость API от внутренней структуры.

```elixir
defprotocol Multiset do
  def add(bag, element)
  def count(bag, element)
  def size(bag)
  def remove(bag, element)
  def contains?(bag, element)
  def empty?(bag)
  def filter(bag, fun)
  def map(bag, fun)
  def foldl(bag, acc, fun)
  def foldr(bag, acc, fun)
  def union(bag1, bag2)
end

```

### Пример кода

Реализация добавления элемента в мультимножество

```elixir
defmodule Multiset.AVLMultiset do
    def add(%AVLMultiset{root: root, size: size} = bag, key) do
        {new_root, delta} = insert(root, key)
        %AVLMultiset{bag | root: new_root, size: size + delta}
    end

    defp insert(nil, key), do: {%Node{value: key}, 1}

    defp insert(%Node{value: v, count: c, left: l, right: r} = node, key) do
        cond do
        key < v ->
            {new_l, delta} = insert(l, key)
            node = balance(%Node{node | left: new_l})
            {node, delta}

        key > v ->
            {new_r, delta} = insert(r, key)
            node = balance(%Node{node | right: new_r})
            {node, delta}

        true ->
            {%Node{node | count: c + 1}, 1}
        end
    end

    defp balance(%Node{left: l, right: r} = node) do
        hl = height(l)
        hr = height(r)
        h = 1 + max(hl, hr)

        case hl - hr do
            d when d > 1 and not is_nil(l) ->
            if height(l.left) >= height(l.right),
                do: rotate_right(%Node{node | height: h}),
                else: rotate_right(%Node{node | height: h, left: rotate_left(l)})

            d when d < -1 and not is_nil(r) ->
            if height(r.right) >= height(r.left),
                do: rotate_left(%Node{node | height: h}),
                else: rotate_left(%Node{node | height: h, right: rotate_right(r)})

            _ ->
            %Node{node | height: h}
        end
    end

    defp rotate_left(%Node{
                value: v,
                count: c,
                left: l,
                right: %Node{value: rv, count: rc, left: rl, right: rr}
            }) do
        h_l = height(l)
        h_rr = height(rr)
        h_rl = height(rl)
        h = 1 + max(h_l, h_rl)

        %Node{
            value: rv,
            count: rc,
            height: 1 + max(h, h_rr),
            left: %Node{value: v, count: c, height: h, left: l, right: rl},
            right: rr
        }
    end

    defp rotate_right(%Node{
                value: v,
                count: c,
                left: %Node{value: lv, count: lc, left: ll, right: lr},
                right: r
            }) do
        h_r = height(r)
        h_l = height(ll)
        h_lr = height(lr)
        h = 1 + max(h_lr, h_r)

        %Node{
            value: lv,
            count: lc,
            height: 1 + max(h_l, h),
            left: ll,
            right: %Node{value: v, count: c, height: h, left: lr, right: r}
        }
    end

    ...
end
```

## Тесты и метрики

### Unit-тесты

Unit-тесты реализованы с использованием ExUnit и покрывают все функции API:

- Проверка добавления и удаления элементов.
- Проверка фильтрации и отображения.
- Проверка сверток и подсчета элементов.
- Проверка корректности работы с пустым мультимножеством.

### Property-based тесты

С использованием библиотеки PropCheck проверены следующие свойства:

1. **Моноид: нейтральный элемент** — объединение с пустым мультимножеством не изменяет содержимое.
2. **Моноид: ассоциативность** — объединение трех мультимножеств в разном порядке дает одинаковый результат.
3. **Идемпотентность фильтрации** — повторное применение фильтрации с тем же предикатом не изменяет результат.

### Тестовое покрытие

|Percentage | Module |
|---|---|
|100.00% | Multiset|
|100.00% | Multiset.AVLMultiset|
|100.00% | Multiset.AVLMultiset.Node|
|100.00% | Multiset.Multiset.AVLMultiset|
|---|---|
|100.00% | Total|

## Выводы

Реализация мультимножества на основе AVL-дерева в Elixir позволила углубленно изучить принципы функционального программирования, включая неизменяемые структуры данных, рекурсию и полиморфизм. Использование протоколов Elixir упростило создание полиморфного API, отделяя интерфейс от реализации.

Property-based тестирование оказалось мощным инструментом для проверки абстрактных свойств, таких как моноидальные законы, и выявило несколько краевых случаев, которые были учтены в реализации. Unit-тесты помогли гарантировать корректность отдельных функций.

Основной вызов заключался в реализации эффективного сравнения мультимножеств, где чтобы избежать наивного приведения к списку пришлось использовать рекурсивную функции свертки.
